#泊松分布的参数的矩估计即为样本均值
num<- c(rep(0:5,c(1532,581,179,41,10,4)))
num2<-c(1532,581,179,41,10,4)
lambda<- mean(num);lambda
k<-0:5
ppois<- dpois(k,lambda)#生成泊松分布的值，根据矩估计
plot(ppois,type='l')
poisnum<- ppois*length(num)
poisnum #根据分布生成损失数
plot(k,poisnum,ylim=c(0,1600))
lines(num2)
samplenum<- as.vector(table(num))
samplenum
points(k,samplenum,type='p',col=2)
legend(4,1000,legend=c('num','poisson'),col=1:2,pch='o')
####计算二阶矩估计
install.packages('rootSolve')
library(rootSolve)
x<- c(4,5,4,3,9,9,5,7,9,8,0,3,8,0,8,7,2,1,1,2)
m1<- mean(x)
m2<- var(x)
model<- function(x,m1,m2){
    c(f1=x[1]+x[2]-2*m1,f2=(x[2]-x[1])^2/12-m2)
 }
library(rootSolve)
multiroot(f=model,start=c(0,10),m1=m1,m2=m2)
#求解结果：m1-sqrt(3*m2) ; m1+qurt(3*m2)  m1 均值 m2 方差
####
######
########极大似然估计
#optimize 单参数分布的极大似然估计
#optim 计算多参数分布的极大似然估计
#nlm 计算非线性函数的最小值
#nlminb  非线性最小化函数
library(MASS)
head(geyser,5)
attach(geyser)
hist(waiting,freq=F)
ll<- function(para)
 {
   f1=dnorm(waiting,para[2],para[3])
   f2=dnorm(waiting,para[4],para[5])
   f=para[1]*f1+(1-para[1])*f2
   ll=sum(log(f))
   return(-ll)
}
geyser.est<- nlminb(c(0.5,50,10,80,10),ll,lower=c(0.0001,-Inf,0.0001,-Inf,0.0001),upper=c(0.999,Inf,Inf,Inf,Inf))
geyser.est$par
